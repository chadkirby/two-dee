// Generated by CoffeeScript 1.6.2
var NumberPair, PI, Polar, abs, atan2, cos, defineProperty, fuzzyEqual, hypot, isNumber, p1, sin, sqrt, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot;

defineProperty = Object.defineProperty;

NumberPair = require('./NumberPair');

Polar = (function(_super) {
  var Complex, defProp;

  __extends(Polar, _super);

  function Polar(rho, theta) {
    if (!(this instanceof Polar)) {
      return new Polar(rho, theta);
    }
    Polar.__super__.constructor.call(this, rho, theta);
    defineProperty(this, 'rho', {
      enumerable: true,
      get: function() {
        return this[0];
      },
      set: function(val) {
        return this[0] = val;
      }
    });
    defineProperty(this, 'theta', {
      enumerable: true,
      get: function() {
        return this[1];
      },
      set: function(val) {
        return this[1] = val;
      }
    });
  }

  defProp = util.defProp.bind(Polar);

  defProp({
    'real, x': {
      get: (function() {
        return this.rho * cos(this.theta);
      }),
      set: function(new_real) {
        var _ref;

        return _ref = this.asPoint().x_(new_real).asPolar(), this.rho = _ref.rho, this.theta = _ref.theta, _ref;
      }
    },
    'imag, y': {
      get: (function() {
        return this.rho * sin(this.theta);
      }),
      set: function(new_imag) {
        var _ref;

        return _ref = this.asPoint().y_(new_imag).asPolar(), this.rho = _ref.rho, this.theta = _ref.theta, _ref;
      }
    },
    magnitude: {
      get: function() {
        return this.rho;
      }
    },
    'angle, phase': {
      get: function() {
        return this.theta;
      }
    }
  });

  Polar.prototype.asPolar = function() {
    return this;
  };

  Polar.prototype.asPoint = function() {
    var Point;

    Point = require('./Point2d');
    return new Point(this.x, this.y);
  };

  Complex = require('./Complex');

  Polar.prototype.asComplex = function() {
    return new Complex(this.real, this.imag);
  };

  Polar.prototype.asString = function(opts) {
    if (opts != null ? opts.degrees : void 0) {
      return this.copy().theta_(this.Polar.reddeg(this.theta)).asString();
    } else {
      return Polar.__super__.asString.apply(this, arguments);
    }
  };

  Polar.prototype.rho_ = function(val) {
    this.rho = val;
    return this;
  };

  Polar.prototype.theta_ = function(val) {
    this.theta = val;
    return this;
  };

  Polar.prototype.x_ = function(val) {
    this.x = val;
    return this;
  };

  Polar.prototype.y_ = function(val) {
    this.y = val;
    return this;
  };

  Polar.prototype.scale = function(scale) {
    return new this.constructor(this.rho * scale, this.theta);
  };

  Polar.prototype.rotate = function(angle) {
    return new this.constructor(this.rho, this.theta + angle);
  };

  Polar.prototype.neg = function() {
    return new this.constructor(this.rho, this.theta + PI);
  };

  Polar.prototype.plus = function(aNumber) {
    return this.asComplex().plus(aNumber);
  };

  Polar.prototype.add = Polar.prototype.plus;

  Polar.prototype.minus = function(aNumber) {
    return this.asComplex().minus(aNumber);
  };

  Polar.prototype.div = function(aNumber) {
    return this.asComplex().div(aNumber);
  };

  Polar.prototype.times = function(aNumber) {
    return this.asComplex().times(aNumber);
  };

  Polar.degrad = function(me) {
    return me * 0.017453292519943295;
  };

  Polar.raddeg = function(me) {
    return me * 57.29577951308232;
  };

  Polar["new"] = function(rho, theta) {
    switch (false) {
      case !(rho instanceof Polar):
        return rho;
      case rho.asPolar == null:
        return rho.asPolar();
      case !isNumber(rho[0], rho[1]):
        return new Polar(rho[0], rho[1]);
      case !isNumber(rho.rho, rho.theta):
        return new Polar(rho.rho, rho.theta);
      case !isNumber(rho, theta):
        return new Polar(rho, theta);
      default:
        console.trace();
        throw "Polar.new requires numeric rho and theta; got " + rho + " and " + theta;
    }
  };

  return Polar;

})(NumberPair);

module.exports = Polar;

if (require.main === module) {
  p1 = Polar(1, 0);
  console.log(p1.plus(1));
}
