// Generated by CoffeeScript 1.7.1
var Complex, NumberPair, PI, abs, atan2, cos, defineProperty, fuzzyEqual, hypot, isNumber, sin, sqrt, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot;

defineProperty = Object.defineProperty;

NumberPair = require('./NumberPair');

Complex = (function(_super) {
  var defProp;

  __extends(Complex, _super);

  function Complex(real, imag) {
    if (!(this instanceof Complex)) {
      return new Complex(real, imag);
    }
    Complex.__super__.constructor.call(this, real, imag);
    defineProperty(this, 'real', {
      enumerable: true,
      get: function() {
        return this[0];
      },
      set: function(val) {
        return this[0] = val;
      }
    });
    defineProperty(this, 'imag', {
      enumerable: true,
      get: function() {
        return this[1];
      },
      set: function(val) {
        return this[1] = val;
      }
    });
  }

  defProp = util.defProp.bind(Complex);

  defProp({
    'magnitude, rho': {
      get: (function() {
        return hypot(this.real, this.imag);
      }),
      set: function(new_real) {
        var _ref;
        return _ref = this.asPolar().rho_(new_real).asComplex(), this.real = _ref.real, this.imag = _ref.imag, _ref;
      }
    },
    'angle, phase, theta': {
      get: (function() {
        return atan2(this.imag, this.real);
      }),
      set: function(new_theta) {
        var _ref;
        return _ref = this.asPolar().theta_(new_theta).asComplex(), this.real = _ref.real, this.imag = _ref.imag, _ref;
      }
    }
  });

  Complex.prototype.asComplex = function() {
    return this;
  };

  Complex.prototype.asPolar = function() {
    var Polar;
    Polar = require('./Polar');
    return new Polar(this.rho, this.theta);
  };

  Complex.prototype.neg = function() {
    return new this.constructor(-this.real, -this.imag);
  };

  Complex.prototype.conjugate = function() {
    return new this.constructor(this.real, -this.imag);
  };

  Complex.prototype.plus = function(aNumber) {
    var _ref;
    aNumber = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.real + aNumber.real, this.imag + aNumber.imag);
  };

  Complex.prototype.add = Complex.prototype.plus;

  Complex.prototype.minus = function(aNumber) {
    var _ref;
    aNumber = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.real - aNumber.real, this.imag - aNumber.imag);
  };

  Complex.prototype.subtract = Complex.prototype.minus;

  Complex.prototype.times = function(aNumber) {
    var _ref;
    aNumber = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor((this.real * aNumber.real) - (this.imag * aNumber.imag), (this.real * aNumber.imag) + (this.imag * aNumber.real));
  };

  Complex.prototype.multiply = Complex.prototype.times;

  Complex.prototype.div = function(aNumber) {
    var denom, yi, yr, _ref;
    aNumber = (_ref = this.constructor)["new"].apply(_ref, arguments);
    yr = aNumber.real;
    yi = aNumber.imag;
    denom = 1 / (yr * yr + (yi * yi));
    return new this.constructor(((this.real * yr) + (this.imag * yi)) * denom, ((this.imag * yr) - (this.real * yi)) * denom);
  };

  Complex.prototype.dividedBy = Complex.prototype.div;

  Complex["new"] = function(real, imag) {
    switch (false) {
      case !(real instanceof Complex):
        return real;
      case real.asComplex == null:
        return real.asComplex();
      case !isNumber(real[0], real[1]):
        return new Complex(real[0], real[1]);
      case !isNumber(real.real, real.imag):
        return new Complex(real.real, real.imag);
      case !isNumber(real, imag):
        return new Complex(real, imag);
      case !isNumber(real):
        return new Complex(real, 0);
      default:
        throw "Complex.new requires numeric real and imag; got " + real + " and " + imag;
        return null;
    }
  };

  return Complex;

})(NumberPair);

module.exports = Complex;
