// Generated by CoffeeScript 1.7.1
var NumberPair, PI, Point2d, abs, atan2, cos, exec, fuzzyEqual, hypot, isNumber, max, min, p, roundTo, sin, sqrt, util,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, max = Math.max, min = Math.min, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot, roundTo = util.roundTo;

NumberPair = require('./NumberPair');

Point2d = (function(_super) {
  var defProp;

  __extends(Point2d, _super);

  function Point2d(x, y) {
    if (!(this instanceof Point2d)) {
      return new Point2d(x, y);
    }
    Point2d.__super__.constructor.call(this, [x, y]);
    Object.defineProperties(this, {
      x: {
        enumerable: true,
        get: function() {
          return this[0];
        },
        set: function(val) {
          return this[0] = val;
        }
      },
      y: {
        enumerable: true,
        get: function() {
          return this[1];
        },
        set: function(val) {
          return this[1] = val;
        }
      }
    });
  }

  defProp = util.defProp.bind(Point2d);

  defProp({
    'rho, magnitude': {
      get: (function() {
        return hypot(this.x, this.y);
      }),
      set: function(new_rho) {
        var _ref;
        return _ref = this.asPolar().rho_(new_rho).asPoint(), this.x = _ref.x, this.y = _ref.y, _ref;
      }
    },
    'theta, angle': {
      get: (function() {
        return atan2(this.y, this.x);
      }),
      set: (function(new_theta) {
        var _ref;
        return _ref = this.asPolar().theta_(new_theta).asPoint(), this.x = _ref.x, this.y = _ref.y, _ref;
      })
    },
    'thetaDeg, angleDeg': {
      get: (function() {
        return atan2(this.y, this.x) * 180 / PI;
      }),
      set: function(new_theta) {
        var _ref;
        new_theta *= 57.29577951308232;
        return _ref = this.asPolar().theta_(new_theta).asPoint(), this.x = _ref.x, this.y = _ref.y, _ref;
      }
    }
  });

  Point2d.prototype.abs = function() {
    return new Point2d(abs(this.x), abs(this.y));
  };

  Point2d.prototype.neg = function() {
    return new Point2d(-this.x, -this.y);
  };

  Point2d.prototype.transpose = function() {
    return new Point2d(this.y, this.x);
  };

  Point2d.prototype.asPoint = function() {
    return this;
  };

  Point2d.prototype.asPolar = function() {
    var Polar;
    Polar = require('./Polar');
    return new Polar(this.rho, this.theta);
  };

  Point2d.prototype.asComplex = function() {
    var Complex;
    Complex = require('./Complex');
    return new Complex(this.x, this.y);
  };

  Point2d.prototype.x_ = function(val) {
    this.x = val;
    return this;
  };

  Point2d.prototype.y_ = function(val) {
    this.y = val;
    return this;
  };

  Point2d.prototype.rho_ = function(val) {
    this.rho = val;
    return this;
  };

  Point2d.prototype.theta_ = function(val) {
    this.theta = val;
    return this;
  };

  Point2d.prototype.plus = function(aPoint) {
    var _ref;
    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x + aPoint.x, this.y + aPoint.y);
  };

  Point2d.prototype.translate = Point2d.prototype.plus;

  Point2d.prototype.add = Point2d.prototype.plus;

  Point2d.prototype.moveBy = Point2d.prototype.plus;

  Point2d.prototype.minus = function(aPoint) {
    var _ref;
    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x - aPoint.x, this.y - aPoint.y);
  };

  Point2d.prototype.subtract = Point2d.prototype.minus;

  Point2d.prototype.div = function(aPoint) {
    var _ref;
    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x / aPoint.x, this.y / aPoint.y);
  };

  Point2d.prototype.dividedBy = Point2d.prototype.div;

  Point2d.prototype.scale = function(aPoint) {
    var _ref;
    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x * aPoint.x, this.y * aPoint.y);
  };

  Point2d.prototype.times = Point2d.prototype.scale;

  Point2d.prototype.multiply = Point2d.prototype.scale;

  Point2d.prototype.dot = function(aPoint) {
    var _ref;
    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return this.x * aPoint.x + this.y * aPoint.y;
  };

  Point2d.prototype.scaleAbout = function() {
    var aPoint, factor, _ref;
    factor = arguments[0], aPoint = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    aPoint = (_ref = this.constructor)["new"].apply(_ref, aPoint);
    if (this.isEq(aPoint)) {
      return this;
    }
    return this.minus(aPoint).scale(factor).plus(aPoint);
  };

  Point2d.prototype.rotate = function(angle, opts) {
    angle;
    var cosr, sinr;
    sinr = sin(angle);
    cosr = cos(angle);
    return new this.constructor((this.x * cosr) - (this.y * sinr), (this.y * cosr) + (this.x * sinr));
  };

  Point2d.prototype.rotateAbout = function() {
    var aPoint, angle, _ref;
    angle = arguments[0], aPoint = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    aPoint = (_ref = this.constructor)["new"].apply(_ref, aPoint);
    return this.minus(aPoint).rotate(angle).plus(aPoint);
  };

  Point2d.prototype.distTo = function(aPoint) {
    var dx, dy, _ref;
    _ref = this.minus.apply(this, arguments), dx = _ref[0], dy = _ref[1];
    return hypot(dx, dy);
  };

  Point2d.prototype.angleTo = function(aPoint) {
    var _ref;
    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return aPoint.minus(this).angle;
  };

  Point2d.prototype.angleToDeg = function() {
    return this.angleTo.apply(this, arguments) * 180 / PI;
  };

  Point2d.quacksLikeAPoint = function(obj) {
    switch (false) {
      case !(obj == null):
        return false;
      case !(obj instanceof Point2d):
        return true;
      case obj.asPoint == null:
        return true;
      case !isNumber(obj.x, obj.y):
        return true;
      case !isNumber(obj[0], obj[1]):
        return true;
      default:
        return false;
    }
  };

  Point2d["new"] = function(x, y) {
    switch (false) {
      case !(x instanceof Point2d):
        return x;
      case x.asPoint == null:
        return x.asPoint();
      case !isNumber(x[0], x[1]):
        return new Point2d(x[0], x[1]);
      case !isNumber(x.x, x.y):
        return new Point2d(x.x, x.y);
      case !isNumber(x, y):
        return new Point2d(x, y);
      case !isNumber(x):
        return new Point2d(x, x);
      default:
        throw "Point2d.new requires numeric x and y; got " + x + " and " + y;
    }
  };

  return Point2d;

})(NumberPair);

Object.defineProperty(Point2d, 'origin', {
  get: function() {
    return new Point2d(0, 0);
  }
});

module.exports = Point2d;

if (require.main === module) {
  exec = require('child_process').exec;
  exec('cake build', function(error, stdout, stderr) {
    return console.log({
      error: error,
      stdout: stdout,
      stderr: stderr
    });
  });
  p = Point2d(0, 1);
  console.log(p.rho);
  console.log(p.magnitude);
  console.log(p.theta);
  console.log(p.angle);
  console.log(p.rho_(2).y);
  console.log(p.theta_(0).isFuzzyEq([2, 0], 1e-10));
}
