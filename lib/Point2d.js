// Generated by CoffeeScript 1.6.2
var NumberPair, PI, Point2d, abs, atan2, cos, fuzzyEqual, hypot, isNumber, key, max, min, o, p, roundTo, sin, sqrt, util, val, _i, _len,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, max = Math.max, min = Math.min, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot, roundTo = util.roundTo;

NumberPair = require('./NumberPair');

Point2d = (function(_super) {
  var defProp, get;

  __extends(Point2d, _super);

  function Point2d(x, y) {
    if (!(this instanceof Point2d)) {
      return new Point2d(x, y);
    }
    Point2d.__super__.constructor.call(this, [x, y]);
    Object.defineProperty(this, 'x', {
      enumerable: true,
      get: function() {
        return this[0];
      },
      set: function(val) {
        return this[0] = val;
      }
    });
    Object.defineProperty(this, 'y', {
      enumerable: true,
      get: function() {
        return this[1];
      },
      set: function(val) {
        return this[1] = val;
      }
    });
  }

  defProp = util.defProp.bind(Point2d);

  defProp({
    'rho, magnitude': {
      get: (function() {
        return hypot(this.x, this.y);
      }),
      set: function(new_rho) {
        var _ref;

        return _ref = this.asPolar.rho_(new_rho).asPoint, this.x = _ref.x, this.y = _ref.y, _ref;
      }
    },
    'theta, angle': {
      get: (function() {
        return atan2(this.y, this.x);
      }),
      set: (function(new_theta) {
        var _ref;

        return _ref = this.asPolar.theta_(new_theta).asPoint, this.x = _ref.x, this.y = _ref.y, _ref;
      })
    }
  });

  get = util.get.bind(Point2d);

  get({
    abs: function() {
      return new Point2d(abs(this.x), abs(this.y));
    }
  });

  get({
    neg: function() {
      return new Point2d(-this.x, -this.y);
    }
  });

  get({
    transpose: function() {
      return new Point2d(this.y, this.x);
    }
  });

  get({
    asPoint: function() {
      return this;
    }
  });

  get({
    asPolar: function() {
      var Polar;

      Polar = require('./Polar2d');
      return new Polar(this.rho, this.theta);
    }
  });

  Point2d.prototype.x_ = function(val) {
    this.x = val;
    return this;
  };

  Point2d.prototype.y_ = function(val) {
    this.y = val;
    return this;
  };

  Point2d.prototype.rho_ = function(val) {
    this.rho = val;
    return this;
  };

  Point2d.prototype.theta_ = function(val) {
    this.theta = val;
    return this;
  };

  Point2d.prototype.plus = function(aPoint) {
    var _ref;

    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x + aPoint.x, this.y + aPoint.y);
  };

  Point2d.prototype.translate = Point2d.prototype.plus;

  Point2d.prototype.add = Point2d.prototype.plus;

  Point2d.prototype.minus = function(aPoint) {
    var _ref;

    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x - aPoint.x, this.y - aPoint.y);
  };

  Point2d.prototype.div = function(aPoint) {
    var _ref;

    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x / aPoint.x, this.y / aPoint.y);
  };

  Point2d.prototype.scale = function(aPoint) {
    var _ref;

    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return new this.constructor(this.x * aPoint.x, this.y * aPoint.y);
  };

  Point2d.prototype.times = Point2d.prototype.scale;

  Point2d.prototype.rotate = function(angle) {
    var cosr, sinr;

    sinr = sin(angle);
    cosr = cos(angle);
    return new this.constructor((this.x * cosr) - (this.y * sinr), (this.y * cosr) + (this.x * sinr));
  };

  Point2d.prototype.dist = function(aPoint) {
    var dx, dy, _ref;

    _ref = this.minus.apply(this, arguments), dx = _ref[0], dy = _ref[1];
    return hypot(dx, dy);
  };

  Point2d.prototype.angleTo = function(aPoint) {
    var _ref;

    aPoint = (_ref = this.constructor)["new"].apply(_ref, arguments);
    return aPoint.minus(this).angle;
  };

  Point2d.prototype.angleToDeg = function() {
    return this.angleTo.apply(this, arguments) * 180 / PI;
  };

  Point2d["new"] = function(x, y) {
    switch (false) {
      case !(x instanceof Point2d):
        return x;
      case !isNumber(x.x, x.y):
        return new Point2d(x.x, x.y);
      case !isNumber(x[0], x[1]):
        return new Point2d(x[0], x[1]);
      case !isNumber(x, y):
        return new Point2d(x, y);
      case !isNumber(x):
        return new Point2d(x, x);
      default:
        console.warn("Point2d.new requires numeric x and y; got " + x + " and " + y);
        return null;
    }
  };

  return Point2d;

})(NumberPair);

Object.defineProperty(Point2d, 'origin', {
  get: function() {
    return new Point2d(0, 0);
  }
});

module.exports = Point2d;

if (require.main === module) {
  p = Point2d(0, 1);
  o = Point2d.origin;
  console.log(p, p.x, p[0], p.y);
  for (key in p) {
    if (!__hasProp.call(p, key)) continue;
    val = p[key];
    console.log(key, val);
  }
  for (_i = 0, _len = p.length; _i < _len; _i++) {
    val = p[_i];
    console.log(val);
  }
}
