// Generated by CoffeeScript 1.6.2
var Line, PI, Point, Polygon, Rect, abs, atan2, cos, flatten, fuzzyEqual, hypot, isNumber, line, match, max, min, pt0, pt1, r, roundTo, s, sin, sqrt, square, util, _i, _len, _ref, _ref1,
  __slice = [].slice;

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, max = Math.max, min = Math.min, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot, roundTo = util.roundTo, square = util.square, flatten = util.flatten;

Point = require('./Point2d');

Line = require('./Line');

Rect = require('./Rect');

Polygon = (function() {
  var defProp;

  function Polygon() {
    var point, points, _i, _len;

    points = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!(this instanceof Polygon)) {
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Polygon, points, function(){});
    }
    this.points = [];
    this._envelope = Rect.infinite();
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      this.push(point);
    }
  }

  Polygon.prototype.push = function(point) {
    return this.setAt(this.points.length, point);
  };

  Polygon.prototype.setAt = function(index, point) {
    var pt;

    pt = Point["new"](point);
    if (pt.x < this._envelope.left) {
      this._envelope.left = pt.x;
    }
    if (pt.y < this._envelope.top) {
      this._envelope.top = pt.y;
    }
    if (pt.x > this._envelope.right) {
      this._envelope.right = pt.x;
    }
    if (pt.y > this._envelope.bottom) {
      this._envelope.bottom = pt.y;
    }
    return this.points[index] = pt;
  };

  Polygon.prototype.addOffsetPoint = function(offset) {
    var pt, _ref;

    pt = (_ref = this.last()).translate.apply(_ref, arguments);
    return this.push(pt);
  };

  defProp = util.defProp.bind(Polygon);

  Polygon.prototype.last = function() {
    return this.points[this.length - 1];
  };

  defProp({
    right: {
      get: function() {
        return this._envelope.right;
      }
    },
    left: {
      get: function() {
        return this._envelope.left;
      }
    },
    top: {
      get: function() {
        return this._envelope.top;
      }
    },
    bottom: {
      get: function() {
        return this._envelope.bottom;
      }
    },
    length: {
      get: function() {
        return this.points.length;
      }
    },
    'width, w': {
      get: function() {
        return this._envelope.width;
      }
    },
    'height, h': {
      get: function() {
        return this._envelope.height;
      }
    },
    x: {
      get: function() {
        return this._envelope.left;
      }
    },
    y: {
      get: function() {
        return this._envelope.top;
      }
    },
    origin: {
      get: function() {
        return this._envelope.origin;
      }
    },
    corner: {
      get: function() {
        return this._envelope.corner;
      }
    },
    extent: {
      get: function() {
        return this._envelope.extent;
      }
    },
    leftTop: {
      get: function() {
        return this._envelope.leftTop;
      }
    },
    rightTop: {
      get: function() {
        return this._envelope.rightTop;
      }
    },
    leftBottom: {
      get: function() {
        return this._envelope.leftBottom;
      }
    },
    rightBottom: {
      get: function() {
        return this._envelope.rightBottom;
      }
    },
    type: {
      get: function() {
        return util.getName(this.constructor);
      }
    }
  });

  Polygon.prototype.lineSegments = function() {
    var p0, p1, segments, _i, _len, _ref;

    segments = [];
    _ref = this.points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p1 = _ref[_i];
      if (typeof p0 !== "undefined" && p0 !== null) {
        segments.push(new Line(p0, p1));
      }
      p0 = p1;
    }
    segments.push(new Line(p0, this.points[0]));
    return segments;
  };

  Polygon.prototype.closestPointOnShape = function(aPoint) {
    var segment;

    aPoint = Point["new"].apply(Point, arguments);
    segment = this.closestShapeSegment(aPoint);
    return segment.closestPointOnSegment(aPoint);
  };

  Polygon.prototype.closestShapeSegment = function(aPoint) {
    var closestSegment, dist, minDist, pt, segment, _i, _len, _ref;

    aPoint = Point["new"].apply(Point, arguments);
    minDist = Infinity;
    closestSegment = null;
    _ref = this.lineSegments();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      segment = _ref[_i];
      pt = segment.closestPointOnSegment(aPoint);
      dist = pt.distTo(aPoint);
      if (dist < minDist) {
        minDist = dist;
        closestSegment = segment;
      }
    }
    return closestSegment;
  };

  Polygon.prototype.envelope = function(offset) {
    if (offset == null) {
      offset = 0;
    }
    return this._envelope.insetBy(-offset, -offset);
  };

  Polygon.prototype.controlPts = function(ptsPerSegment) {
    var denom, ii, line, out, _i, _j, _len, _ref;

    if (ptsPerSegment == null) {
      ptsPerSegment = 2;
    }
    out = [];
    denom = ptsPerSegment + 1;
    _ref = this.lineSegments();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      for (ii = _j = 1; 1 <= ptsPerSegment ? _j <= ptsPerSegment : _j >= ptsPerSegment; ii = 1 <= ptsPerSegment ? ++_j : --_j) {
        out.push(line.at(ii / denom));
      }
    }
    return out;
  };

  Polygon.prototype.inspect = function() {
    return "" + this.type + "( " + (this.asString({
      fixed: 4
    })) + " )";
  };

  Polygon.prototype.asString = function(opts) {
    var out, point;

    out = (function() {
      var _i, _len, _ref, _results;

      _ref = this.points;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        _results.push(point.asString(opts));
      }
      return _results;
    }).call(this);
    return "[" + (out.join('], [')) + "]";
  };

  Polygon.prototype.svgString = function(opts) {
    var ii, pt, svg;

    if (opts == null) {
      opts = {};
    }
    svg = (function() {
      var _i, _len, _ref, _results;

      _ref = this.points;
      _results = [];
      for (ii = _i = 0, _len = _ref.length; _i < _len; ii = ++_i) {
        pt = _ref[ii];
        _results.push(pt.asString(opts));
      }
      return _results;
    }).call(this);
    return "M" + (svg.join('  L')) + " z";
  };

  Polygon.prototype.map = function(fn) {
    var ii, pt, _i, _len, _ref, _results;

    _ref = this.points;
    _results = [];
    for (ii = _i = 0, _len = _ref.length; _i < _len; ii = ++_i) {
      pt = _ref[ii];
      _results.push(fn(pt, ii));
    }
    return _results;
  };

  Polygon.prototype.moveBy = function(h, v) {
    var pts;

    pts = this.map(function(pt) {
      return pt.translate(h, v);
    });
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(this.constructor, pts, function(){});
  };

  Polygon.prototype.translate = Polygon.prototype.moveBy;

  Polygon.prototype.moveTo = function(aPoint) {
    var delta;

    aPoint = Point["new"].apply(Point, arguments);
    delta = aPoint.minus(this.points[0]);
    return this.moveBy(delta);
  };

  Polygon.prototype.scaleAbout = function(scale, origin) {
    var pts;

    scale = Point["new"](scale);
    pts = this.map(function(pt) {
      return pt.scaleAbout(scale, origin);
    });
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(this.constructor, pts, function(){});
  };

  Polygon.prototype.rotateAbout = function(rotate, origin) {
    var pts;

    pts = this.map(function(pt) {
      return pt.rotateAbout(rotate, origin);
    });
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(this.constructor, pts, function(){});
  };

  Polygon.prototype.scale = function(h, v) {
    var origin, pts, scale;

    scale = Point["new"].apply(Point, arguments);
    origin = this.points[0];
    pts = this.map(function(pt) {
      return pt.scaleAbout(scale, origin);
    });
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(this.constructor, pts, function(){});
  };

  Polygon.prototype.resizeBy = Polygon.prototype.scale;

  Polygon.prototype.area = function() {
    var area, i, j, nPts, p1, p2, pts;

    area = 0;
    pts = this.points;
    nPts = pts.length;
    j = nPts - 1;
    p1 = void 0;
    p2 = void 0;
    i = 0;
    while (i < nPts) {
      p1 = pts[i];
      p2 = pts[j];
      area += p1.x * p2.y;
      area -= p1.y * p2.x;
      j = i++;
    }
    area /= 2;
    return area;
  };

  Polygon.prototype.centroid = function() {
    var f, i, j, nPts, p1, p2, pts, x, y;

    pts = this.points;
    nPts = pts.length;
    x = 0;
    y = 0;
    f = void 0;
    j = nPts - 1;
    p1 = void 0;
    p2 = void 0;
    i = 0;
    while (i < nPts) {
      p1 = pts[i];
      p2 = pts[j];
      f = p1.x * p2.y - p2.x * p1.y;
      x += (p1.x + p2.x) * f;
      y += (p1.y + p2.y) * f;
      j = i++;
    }
    f = this.area() * 6;
    return Point["new"](x / f, y / f);
  };

  return Polygon;

})();

module.exports = Polygon;

if (require.main === module) {
  r = Polygon([61.427898, 72.746506]);
  s = "l13.11,-25.45 \nl2.74,-46.09  \nl-21.956,-0.46 \nl-24.6,3.8  \nl3.94,62.26 ";
  _ref = s.split('\n');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    line = _ref[_i];
    _ref1 = /l(.+),(.+)/.exec(line), match = _ref1[0], pt0 = _ref1[1], pt1 = _ref1[2];
    r.addOffsetPoint(+pt0, +pt1);
  }
  console.log(r.scale(0.5).translate(5, 5).controlPts(1));
  console.log(r.moveBy(10, 10));
  console.log(r.controlPts(1));
  console.log(r.svgString({
    fixed: 4
  }));
  console.log(r.envelope);
  console.log(r.area(), r.centroid());
  console.log(r.rotateAbout(Math.PI, r.centroid()));
}
