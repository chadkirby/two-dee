// Generated by CoffeeScript 1.6.2
var PI, Point, Rect, abs, atan2, cos, fuzzyEqual, hypot, isNumber, max, min, r, roundTo, sin, sqrt, square, util;

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, max = Math.max, min = Math.min, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot, roundTo = util.roundTo, square = util.square;

Point = require('./Point2d');

Rect = (function() {
  var defProp;

  function Rect(left, top, right, bottom) {
    if (left == null) {
      left = 0;
    }
    if (top == null) {
      top = 0;
    }
    if (right == null) {
      right = 0;
    }
    if (bottom == null) {
      bottom = 0;
    }
    if (!(this instanceof Rect)) {
      return new Rect(left, top, right, bottom);
    }
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }

  defProp = util.defProp.bind(Rect);

  defProp({
    'width, w': {
      get: function() {
        return this.right - this.left;
      },
      set: function(h) {
        return this.width_(h);
      }
    },
    'height, h': {
      get: function() {
        return this.bottom - this.top;
      },
      set: function(v) {
        return this.height_(v);
      }
    },
    x: {
      get: function() {
        return this.left;
      }
    },
    y: {
      get: function() {
        return this.top;
      }
    },
    origin: {
      get: function() {
        return Point["new"](this.left, this.top);
      }
    },
    corner: {
      get: function() {
        return Point["new"](this.right, this.bottom);
      }
    },
    extent: {
      get: function() {
        return Point["new"](this.right - this.left, this.bottom - this.top);
      }
    },
    leftTop: {
      get: function() {
        return Point["new"](this.left, this.top);
      }
    },
    rightTop: {
      get: function() {
        return Point["new"](this.right, this.top);
      }
    },
    leftBottom: {
      get: function() {
        return Point["new"](this.left, this.bottom);
      }
    },
    rightBottom: {
      get: function() {
        return Point["new"](this.right, this.bottom);
      }
    },
    type: {
      get: function() {
        return util.getName(this.constructor);
      }
    }
  });

  Rect.prototype.width_ = function(h) {
    this.right = this.left + h;
    return this;
  };

  Rect.prototype.height_ = function(v) {
    this.bottom = this.top + v;
    return this;
  };

  Rect.prototype.copy = function() {
    return new this.constructor(this.left, this.right, this.top, this.bottom);
  };

  Rect.prototype.inspect = function() {
    return "" + this.type + "( " + (this.asString()) + " )";
  };

  Rect.prototype.asString = function(opts) {
    return "" + this.left + ", " + this.top + ", " + this.right + ", " + this.bottom;
  };

  Rect.prototype.svgString = function(opts) {
    var svg;

    if (opts == null) {
      opts = {};
    }
    svg = opts.ccw || opts.inside || /^cc|counter|inside/.test(opts.direction || opts.wind) ? ["l 0, " + this.height, "l " + this.width + ", 0 ", "l 0, -" + this.height] : ["l " + this.width + ", 0 ", "l 0, " + this.height, "l -" + this.width + ", 0"];
    svg.unshift("M " + (this.origin.asString()));
    svg.push("z");
    return svg.join('   ');
  };

  Rect.prototype.envelope = function(offset) {
    if (offset == null) {
      offset = 3;
    }
    return this.insetBy(-offset, -offset);
  };

  Rect.prototype.moveBy = function(h, v) {
    return new Rect(this.left + h, this.top + v, this.right + h, this.bottom + v);
  };

  Rect.prototype.moveTo = function(aPoint) {
    aPoint = Point["new"].apply(Point, arguments);
    return new Rect(aPoint.x, aPoint.y, this.right - this.left + aPoint.x, this.bottom - this.top + aPoint.y);
  };

  Rect.prototype.resizeBy = function(h, v) {
    return new Rect(this.left, this.top, this.right + h, this.bottom + v);
  };

  Rect.prototype.resizeTo = function(h, v) {
    return new Rect(this.left, this.top, this.left + h, this.top + v);
  };

  Rect.prototype.insetBy = function(h, v) {
    return new Rect(this.left + h, this.top + v, this.right - h, this.bottom - v);
  };

  Rect.prototype.insetAll = function(a, b, c, d) {
    return new Rect(this.left + a, this.top + b, this.right - c, this.bottom - d);
  };

  Rect.prototype.contains = function(aPoint) {
    return uitl.inclusivelyBetween(aPoint.x, this.left, this.right) && uitl.inclusivelyBetween(aPoint.y, this.bottom, this.top);
  };

  Rect.prototype.intersects = function(aRect) {
    aRect = Rect["new"](aRect);
    if (aRect.right < this.left) {
      return false;
    }
    if (aRect.bottom < this.top) {
      return false;
    }
    if (aRect.left > this.right) {
      return false;
    }
    if (aRect.top > this.bottom) {
      return false;
    }
    return true;
  };

  Rect["new"] = function(arg0, arg1, arg2, arg3) {
    var hgt, p0, p1, wid;

    switch (false) {
      case !(arg0 instanceof Rect):
        return arg0;
      case !Point.quacksLikeAPoint(arg0):
        p0 = Point["new"](arg0);
        if (Point.quacksLikeAPoint(arg1)) {
          p1 = Point["new"](arg1);
          return new Rect(min(p0.x, p1.x), min(p0.y, p1.y), max(p0.x, p1.x), max(p0.y, p1.y));
        } else if (isNumber(arg1, arg2)) {
          wid = arg1;
          hgt = arg2;
          return new Rect(p0.x, p0.y, p0.x + wid, p0.y + hgt);
        }
        break;
      default:
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Rect, arguments, function(){});
    }
  };

  return Rect;

})();

module.exports = Rect;

if (require.main === module) {
  r = Rect["new"]([0, 0], 10, 3);
  console.log(r);
  console.log(r.svgString());
  console.log(r.svgString({
    ccw: true
  }));
  console.log(r.envelope());
}
