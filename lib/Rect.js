// Generated by CoffeeScript 1.6.2
var PI, Point, Rect, abs, atan2, cos, fuzzyEqual, hypot, i, isNumber, max, min, r, roundTo, sin, sqrt, square, util, _i;

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, max = Math.max, min = Math.min, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot, roundTo = util.roundTo, square = util.square;

Point = require('./Point2d');

Rect = (function() {
  var defProp;

  function Rect(left, top, right, bottom) {
    if (left == null) {
      left = 0;
    }
    if (top == null) {
      top = 0;
    }
    if (right == null) {
      right = 0;
    }
    if (bottom == null) {
      bottom = 0;
    }
    if (!(this instanceof Rect)) {
      return new Rect(left, top, right, bottom);
    }
    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
  }

  defProp = util.defProp.bind(Rect);

  defProp({
    'width, w': {
      get: function() {
        return this.right - this.left;
      },
      set: function(h) {
        return this.right = this.left + h;
      }
    },
    'height, h': {
      get: function() {
        return this.bottom - this.top;
      },
      set: function(v) {
        return this.bottom = this.top + v;
      }
    },
    x: {
      get: function() {
        return this.left;
      },
      set: function(x) {
        var w;

        w = this.w;
        this.left = x;
        return this.right = x + w;
      }
    },
    y: {
      get: function() {
        return this.top;
      },
      set: function(y) {
        var h;

        h = this.h;
        this.top = y;
        return this.bottom = y + h;
      }
    },
    origin: {
      get: function() {
        return Point["new"](this.left, this.top);
      }
    },
    corner: {
      get: function() {
        return Point["new"](this.right, this.bottom);
      }
    },
    extent: {
      get: function() {
        return Point["new"](this.right - this.left, this.bottom - this.top);
      }
    },
    'leftTop, topLeft': {
      get: function() {
        return Point["new"](this.left, this.top);
      }
    },
    'rightTop, topRight': {
      get: function() {
        return Point["new"](this.right, this.top);
      }
    },
    'leftBottom, bottomLeft': {
      get: function() {
        return Point["new"](this.left, this.bottom);
      }
    },
    'rightBottom, bottomRight': {
      get: function() {
        return Point["new"](this.right, this.bottom);
      }
    },
    type: {
      get: function() {
        return util.getName(this.constructor);
      }
    },
    center: {
      get: function() {
        return this.origin.translate(this.extent.scale(0.5));
      }
    }
  });

  Rect.prototype.copy = function() {
    return new this.constructor(this.left, this.top, this.right, this.bottom);
  };

  Rect.prototype.inspect = function() {
    return "" + this.type + "( " + (this.asString()) + " )";
  };

  Rect.prototype.asString = function(opts) {
    return "" + this.left + ", " + this.top + ", " + this.width + ", " + this.height;
  };

  Rect.prototype.asPolygon = function() {
    var Polygon;

    Polygon = require('./Polygon');
    return Polygon.apply(null, [this.leftTop, this.rightTop, this.rightBottom, this.leftBottom]);
  };

  Rect.prototype.rotate = function(angle) {
    return this.asPolygon().rotateAbout(angle, this.leftTop);
  };

  Rect.prototype.lineSegments = function() {
    var Line;

    Line = require('./Line');
    return {
      left: new Line(this.leftTop, this.leftBottom),
      right: new Line(this.rightTop, this.rightBottom),
      top: new Line(this.topLeft, this.topRight),
      bottom: new Line(this.bottomLeft, this.bottomRight)
    };
  };

  Rect.prototype.closestPointOnShape = function(aPoint) {
    var segment;

    aPoint = Point["new"].apply(Point, arguments);
    segment = this.closestShapeSegment(aPoint);
    return segment.closestPointOnSegment(aPoint);
  };

  Rect.prototype.closestShapeSegment = function(aPoint) {
    var closestSegment, dist, key, minDist, pt, segment, _ref;

    aPoint = Point["new"].apply(Point, arguments);
    minDist = Infinity;
    closestSegment = null;
    _ref = this.lineSegments();
    for (key in _ref) {
      segment = _ref[key];
      pt = segment.closestPointOnSegment(aPoint);
      dist = pt.distTo(aPoint);
      if (dist < minDist) {
        minDist = dist;
        closestSegment = segment;
      }
    }
    return closestSegment;
  };

  Rect.prototype.svgString = function(opts) {
    var svg;

    if (opts == null) {
      opts = {};
    }
    svg = opts.ccw || opts.inside || /^cc|counter|inside/.test(opts.direction || opts.wind) ? ["l 0, " + this.height, "l " + this.width + ", 0 ", "l 0, -" + this.height] : ["l " + this.width + ", 0 ", "l 0, " + this.height, "l -" + this.width + ", 0"];
    svg.unshift("M " + (this.origin.asString()));
    svg.push("z");
    return svg.join('   ');
  };

  Rect.prototype.envelope = function(offset) {
    if (offset == null) {
      offset = 3;
    }
    return this.insetBy(-offset, -offset);
  };

  Rect.prototype.inflate = Rect.prototype.envelope;

  Rect.prototype.moveBy = function(h, v) {
    var pt;

    pt = Point["new"].apply(Point, arguments);
    return new Rect(this.left + pt.x, this.top + pt.y, this.right + pt.x, this.bottom + pt.y);
  };

  Rect.prototype.translate = Rect.prototype.moveBy;

  Rect.prototype.moveTo = function(aPoint) {
    aPoint = Point["new"].apply(Point, arguments);
    return new Rect(aPoint.x, aPoint.y, this.width + aPoint.x, this.height + aPoint.y);
  };

  Rect.prototype.resizeBy = function(h, v) {
    return new Rect(this.left, this.top, this.right + h, this.bottom + v);
  };

  Rect.prototype.scale = function(factor) {
    return this.resizeTo(this.w * factor, this.h * factor);
  };

  Rect.prototype.resizeTo = function(h, v) {
    return new Rect(this.left, this.top, this.left + h, this.top + v);
  };

  Rect.prototype.insetBy = function(h, v) {
    return new Rect(this.left + h, this.top + v, this.right - h, this.bottom - v);
  };

  Rect.prototype.insetAll = function(a, b, c, d) {
    return new Rect(this.left + a, this.top + b, this.right - c, this.bottom - d);
  };

  Rect.prototype.contains = function(aPoint) {
    var x, y;

    x = aPoint.x, y = aPoint.y;
    return ((this.left <= x && x <= this.right)) && ((this.bottom <= y && y <= this.top));
  };

  Rect.prototype.includes = function(aRect) {
    aRect = Rect["new"](aRect);
    if (aRect.right > this.right) {
      return false;
    }
    if (aRect.bottom > this.bottom) {
      return false;
    }
    if (aRect.left < this.left) {
      return false;
    }
    if (aRect.top < this.top) {
      return false;
    }
    return true;
  };

  Rect.prototype.intersects = function(aRect) {
    aRect = Rect["new"](aRect);
    if (aRect.right < this.left) {
      return false;
    }
    if (aRect.bottom < this.top) {
      return false;
    }
    if (aRect.left > this.right) {
      return false;
    }
    if (aRect.top > this.bottom) {
      return false;
    }
    return true;
  };

  Rect.prototype.positionComparedTo = function(aRect, opts) {
    var above, below, leftOf, otherPt, pt, rightOf, xAligned, yAligned, _ref, _ref1;

    if (opts == null) {
      opts = {};
    }
    aRect = Rect["new"](aRect);
    if ((_ref = opts.referencePoint) == null) {
      opts.referencePoint = 'center';
    }
    if ((_ref1 = opts.flipY) == null) {
      opts.flipY = false;
    }
    pt = this[opts.referencePoint];
    otherPt = aRect[opts.referencePoint];
    below = opts.flipY ? otherPt.y > pt.y : otherPt.y < pt.y;
    above = opts.flipY ? otherPt.y < pt.y : otherPt.y > pt.y;
    yAligned = pt.y === otherPt.y;
    leftOf = pt.x > otherPt.x;
    rightOf = pt.x < otherPt.x;
    xAligned = pt.x === otherPt.x;
    return {
      below: below,
      above: above,
      leftOf: leftOf,
      rightOf: rightOf,
      xAligned: xAligned,
      yAligned: yAligned
    };
  };

  Rect.prototype.randomPoint = function() {
    var buf, crypto, pt, randX, randY;

    crypto = require('crypto');
    pt = this.origin;
    buf = crypto.randomBytes(4);
    randX = this.width * buf.readUInt16LE(0) / 65536;
    randY = this.height * buf.readUInt16LE(2) / 65536;
    return pt.moveBy(randX, randY);
  };

  Rect.infinite = function() {
    return new Rect(Infinity, Infinity, -Infinity, -Infinity);
  };

  Rect["new"] = function(arg0, arg1, arg2, arg3) {
    var hgt, p0, p1, wid, _ref, _ref1, _ref2, _ref3;

    switch (false) {
      case !(arg0 instanceof Rect):
        return arg0;
      case !Point.quacksLikeAPoint(arg0):
        p0 = Point["new"](arg0);
        if (Point.quacksLikeAPoint(arg1)) {
          p1 = Point["new"](arg1);
          return new Rect(min(p0.x, p1.x), min(p0.y, p1.y), max(p0.x, p1.x), max(p0.y, p1.y));
        } else if (isNumber(arg1, arg2)) {
          wid = arg1;
          hgt = arg2;
          return new Rect(p0.x, p0.y, p0.x + wid, p0.y + hgt);
        } else if (isNumber((_ref = arg0.w) != null ? _ref : arg0.width, (_ref1 = arg0.h) != null ? _ref1 : arg0.height)) {
          wid = (_ref2 = arg0.w) != null ? _ref2 : arg0.width;
          hgt = (_ref3 = arg0.h) != null ? _ref3 : arg0.height;
          return new Rect(p0.x, p0.y, p0.x + wid, p0.y + hgt);
        }
        break;
      default:
        return (function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(Rect, arguments, function(){});
    }
  };

  return Rect;

})();

module.exports = Rect;

if (require.main === module) {
  r = Rect["new"]([0, 0], 10, 3);
  r = Rect["new"]({
    x: 1,
    y: 0,
    w: 10,
    h: 1
  });
  console.log(r);
  for (i = _i = 0; _i <= 10; i = ++_i) {
    console.log(i, r.randomPoint());
  }
}
