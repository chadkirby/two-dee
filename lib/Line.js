// Generated by CoffeeScript 1.6.2
var LineSegment, PI, Point, abs, atan2, cos, fuzzyEqual, hypot, isNumber, l, max, min, roundTo, sin, sqrt, square, util;

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, max = Math.max, min = Math.min, PI = Math.PI;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot, roundTo = util.roundTo, square = util.square;

Point = require('./Point2d');

LineSegment = (function() {
  var defProp;

  function LineSegment(p0, p1) {
    if (!(this instanceof LineSegment)) {
      return new LineSegment(p0, p1);
    }
    this.points = [Point["new"](p0), Point["new"](p1)];
  }

  defProp = util.defProp.bind(LineSegment);

  defProp({
    'p0, start': {
      get: function() {
        return this.points[0];
      },
      set: function(val) {
        return this.points[0] = Point["new"].apply(Point, arguments);
      }
    },
    'p1, end': {
      get: function() {
        return this.points[1];
      },
      set: function(val) {
        return this.points[1] = Point["new"].apply(Point, arguments);
      }
    },
    x0: {
      get: function() {
        return this.start.x;
      }
    },
    x1: {
      get: function() {
        return this.end.x;
      }
    },
    y0: {
      get: function() {
        return this.start.y;
      }
    },
    y1: {
      get: function() {
        return this.end.y;
      }
    },
    length: {
      get: function() {
        return this.p0.dist(this.p1);
      },
      set: function(val) {
        return this.end = this.end.scaleAbout(val, this.start);
      }
    },
    dx: {
      get: function() {
        return this.end.x - this.start.x;
      }
    },
    dy: {
      get: function() {
        return this.end.y - this.start.y;
      }
    },
    'slope, m': {
      get: function() {
        return this.dy / this.dx;
      }
    },
    yIntercept: {
      get: function() {
        return this.yAt(0);
      }
    },
    type: {
      get: function() {
        return util.getName(this.constructor);
      }
    }
  });

  LineSegment.prototype.copy = function() {
    return new this.constructor(this.start, this.end);
  };

  LineSegment.prototype.inspect = function() {
    return "" + this.type + "( " + (this.asString()) + " )";
  };

  LineSegment.prototype.asString = function(opts) {
    return "[" + (this.start.asString(opts)) + "], [" + (this.end.asString(opts)) + "]";
  };

  LineSegment.prototype.mapPoints = function(fn) {
    var i, point;

    this.points = (function() {
      var _i, _len, _ref, _results;

      _ref = this.points;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        point = _ref[i];
        _results.push(fn(point, i));
      }
      return _results;
    }).call(this);
    return this;
  };

  LineSegment.prototype.scaleAbout = function(factor, origin) {
    if (origin == null) {
      origin = Point.origin;
    }
    return this.mapPoints(function(point, i) {
      return point.scaleAbout(factor, origin);
    });
  };

  LineSegment.prototype.rotateAbout = function(factor, origin) {
    if (origin == null) {
      origin = Point.origin;
    }
    return this.mapPoints(function(point, i) {
      return point.rotateAbout(factor, origin);
    });
  };

  LineSegment.prototype.translate = function(aPoint) {
    aPoint = Point["new"].apply(Point, arguments);
    return this.copy().mapPoints(function(point, i) {
      console.log(point, aPoint, point.translate(aPoint));
      return point.translate(aPoint);
    });
  };

  LineSegment.prototype.yAt = function(x) {
    return this.m * (x - this.x0) + this.y0;
  };

  LineSegment.prototype.pointAt = function(tt) {
    return Point(this.x0 + tt * this.dx, this.y0 + tt * this.dy);
  };

  LineSegment.prototype.svgString = function() {
    return "M " + (this.start.asString()) + " L " + (this.end.asString());
  };

  LineSegment.prototype.envelope = function(offset) {
    var Rect, rr;

    if (offset == null) {
      offset = 3;
    }
    if (this.dx === 0 || this.dy === 0) {
      Rect = require('./Rect');
      rr = Rect["new"](this.start, this.end);
      return rr.envelope(offset);
    }
  };

  LineSegment.prototype._closestTT = function(aPoint, min, max) {
    var AP, ab2, ap_ab, tt;

    AP = aPoint.minus(this.start);
    ab2 = this.dx * this.dx + this.dy * this.dy;
    ap_ab = AP.x * this.dx + AP.y * this.dy;
    tt = ap_ab / ab2;
    if ((min != null) && tt < min) {
      return min;
    } else if ((max != null) && tt > max) {
      return max;
    } else {
      return tt;
    }
  };

  LineSegment.prototype.distToPoint = function(aPoint) {
    var tt;

    aPoint = Point["new"].apply(Point, arguments);
    tt = this._closestTT(aPoint, 0, 1);
    return this.pointAt(tt).distTo(aPoint);
  };

  LineSegment.prototype.closestPointOnSegment = function(aPoint) {
    var tt;

    aPoint = Point["new"].apply(Point, arguments);
    tt = this._closestTT(aPoint, 0, 1);
    return this.pointAt(tt);
  };

  LineSegment.prototype.closestPointOnLine = function(aPoint) {
    var tt;

    aPoint = Point["new"].apply(Point, arguments);
    tt = this._closestTT(aPoint);
    return this.pointAt(tt);
  };

  return LineSegment;

})();

module.exports = LineSegment;

if (require.main === module) {
  l = LineSegment([0, 0], [5, 5]);
  console.log(l);
  console.log(l.svgString());
  console.log(l.distToPoint(2, 3));
  console.log(l.yAt(4));
  console.log(l.pointAt(0.4));
  console.log(l.closestPointOnSegment(-1, 0));
  console.log(l.closestPointOnLine(-1, 0));
  l = LineSegment([0, 0], [5, 0]);
  console.log(l.envelope());
}
