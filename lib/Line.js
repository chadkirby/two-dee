// Generated by CoffeeScript 1.9.1
var LineSegment, PI, Point, abs, atan2, ceil, cos, fuzzyEqual, hypot, interleave, isNumber, l, m, max, min, round, roundTo, sin, sqrt, square, util,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, sqrt = Math.sqrt, abs = Math.abs, max = Math.max, min = Math.min, PI = Math.PI, round = Math.round, ceil = Math.ceil;

util = require('./utilities');

isNumber = util.isNumber, fuzzyEqual = util.fuzzyEqual, hypot = util.hypot, roundTo = util.roundTo, square = util.square;

Point = require('./Point2d');

interleave = function() {
  var arr, ii, list, lists;
  lists = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  arr = [];
  ii = 0;
  while ((list = lists.shift())) {
    if (!(list.length > 0)) {
      continue;
    }
    arr.push(list.shift());
    lists.push(list);
  }
  return arr;
};

LineSegment = (function() {
  var Rect, defProp;

  function LineSegment(p0, p1) {
    if (!(this instanceof LineSegment)) {
      return new LineSegment(p0, p1);
    }
    this.points = [Point["new"](p0), Point["new"](p1)];
  }

  defProp = util.defProp.bind(LineSegment);

  defProp({
    'p0, start': {
      get: function() {
        return this.points[0];
      },
      set: function() {
        return this.points[0] = Point["new"].apply(Point, arguments);
      }
    },
    p1: {
      get: function() {
        return this.points[1];
      },
      set: function() {
        return this.points[1] = Point["new"].apply(Point, arguments);
      }
    },
    end: {
      get: function() {
        return this.points[this.points.length - 1];
      },
      set: function() {
        return this.points[this.points.length - 1] = Point["new"].apply(Point, arguments);
      }
    },
    x0: {
      get: function() {
        return this.start.x;
      }
    },
    x1: {
      get: function() {
        return this.end.x;
      }
    },
    y0: {
      get: function() {
        return this.start.y;
      }
    },
    y1: {
      get: function() {
        return this.end.y;
      }
    },
    length: {
      get: function() {
        return this.p0.distTo(this.p1);
      },
      set: function(val) {
        return this.end = this.end.scaleAbout(val / this.length, this.start);
      }
    },
    dx: {
      get: function() {
        return this.end.x - this.start.x;
      }
    },
    dy: {
      get: function() {
        return this.end.y - this.start.y;
      }
    },
    center: {
      get: function() {
        return Point["new"](this.x0 + this.dx / 2, this.y0 + this.dy / 2);
      }
    },
    'slope, m': {
      get: function() {
        return this.dy / this.dx;
      }
    },
    yIntercept: {
      get: function() {
        return this.yAt(0);
      }
    },
    type: {
      get: function() {
        return util.getName(this.constructor);
      }
    },
    normal: {
      get: function() {
        return new this.constructor(Point["new"](-this.dy, this.dx), Point["new"](this.dy, -this.dx));
      }
    },
    A: {
      get: function() {
        return this.p1.y - this.p0.y;
      }
    },
    B: {
      get: function() {
        return this.p0.x - this.p1.x;
      }
    },
    C: {
      get: function() {
        return this.A * this.p0.x + this.B * this.p0.y;
      }
    }
  });

  LineSegment.prototype.copy = function() {
    return new this.constructor(this.start, this.end);
  };

  LineSegment.prototype.inspect = function() {
    return this.type + "( " + (this.asString()) + " )";
  };

  LineSegment.prototype.asString = function(opts) {
    return "[" + (this.start.asString(opts)) + "], [" + (this.end.asString(opts)) + "]";
  };

  Rect = require('./Rect');

  LineSegment.prototype.asRect = function() {
    return Rect["new"](this.start, this.end);
  };

  LineSegment.prototype.mapPoints = function(fn) {
    var i, point;
    this.points = (function() {
      var j, len, ref, results;
      ref = this.points;
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        point = ref[i];
        results.push(fn(point, i));
      }
      return results;
    }).call(this);
    return this;
  };

  LineSegment.prototype.transpose = function() {
    return new this.constructor(this.p1, this.p0);
  };

  LineSegment.prototype.splitN = function(numberOfPieces) {
    var nn, tt, tts;
    nn = 1 / Math.max(1, numberOfPieces);
    tts = (function() {
      var j, ref, ref1, results;
      results = [];
      for (tt = j = ref = nn, ref1 = nn; ref1 > 0 ? j <= 1 : j >= 1; tt = j += ref1) {
        results.push(tt);
      }
      return results;
    })();
    if (numberOfPieces % 1 === 0) {
      tts.push(round(tts.pop()));
    }
    return this.split.apply(this, tts);
  };

  LineSegment.prototype.split = function() {
    var j, len, p0, p1, results, tt, tts;
    tts = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    tts = util.flatten(tts);
    if (!(indexOf.call(tts, 1) >= 0)) {
      tts.push(1);
    }
    results = [];
    for (j = 0, len = tts.length; j < len; j++) {
      tt = tts[j];
      if (!(tt > 0)) {
        continue;
      }
      p0 = typeof p1 !== "undefined" && p1 !== null ? p1 : this.p0;
      p1 = this.pointAt(tt);
      results.push(new this.constructor(p0, p1));
    }
    return results;
  };

  LineSegment.prototype.asPath = function(maxPointSpacing) {
    var j, len, nn, results, segmentCount, tt, tts;
    segmentCount = this.length / maxPointSpacing;
    nn = 1 / Math.max(1, segmentCount);
    tts = (function() {
      var j, ref, ref1, results;
      results = [];
      for (tt = j = 0, ref = 1 - nn, ref1 = nn; ref1 > 0 ? j <= ref : j >= ref; tt = j += ref1) {
        results.push(tt);
      }
      return results;
    })();
    tts.push(1);
    results = [];
    for (j = 0, len = tts.length; j < len; j++) {
      tt = tts[j];
      results.push(this.pointAt(tt));
    }
    return results;
  };

  LineSegment.prototype.scaleAbout = function(factor, origin) {
    if (origin == null) {
      origin = Point.origin;
    }
    return this.copy().mapPoints(function(point, i) {
      return point.scaleAbout(factor, origin);
    });
  };

  LineSegment.prototype.extendBy = function(additionalLength) {
    var tt;
    tt = (this.length + additionalLength) / this.length;
    return new this.constructor(this.p0, this.pointAt(tt));
  };

  LineSegment.prototype.rotateAbout = function(factor, origin) {
    if (origin == null) {
      origin = Point.origin;
    }
    return this.mapPoints(function(point, i) {
      return point.rotateAbout(factor, origin);
    });
  };

  LineSegment.prototype.rotate = function(factor) {
    var copy;
    copy = this.copy();
    copy.p1 = copy.p1.rotateAbout(factor, copy.p0);
    return copy;
  };

  LineSegment.prototype.translate = function(aPoint) {
    aPoint = Point["new"].apply(Point, arguments);
    return this.copy().mapPoints(function(point, i) {
      return point.translate(aPoint);
    });
  };

  LineSegment.prototype.moveBy = LineSegment.prototype.translate;

  LineSegment.prototype.moveTo = function(aPoint) {
    var delta;
    aPoint = Point["new"].apply(Point, arguments);
    delta = aPoint.minus(this.start);
    return new this.constructor(aPoint, this.end.translate(delta));
  };

  LineSegment.prototype.splitFromCenter = function() {
    var l0, l1, ref;
    ref = this.split(0.5), l0 = ref[0], l1 = ref[1];
    return [l0.transpose(), l1];
  };

  LineSegment.prototype.centerAt = function(aPoint) {
    var i, l0, l1, ref, segment;
    aPoint = Point["new"].apply(Point, arguments);
    ref = (function() {
      var j, len, ref, results;
      ref = this.splitFromCenter();
      results = [];
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        segment = ref[i];
        results.push(segment.moveTo(aPoint));
      }
      return results;
    }).call(this), l0 = ref[0], l1 = ref[1];
    return new this.constructor(l0.p1, l1.p1);
  };

  LineSegment.prototype.yAt = function(x) {
    return this.m * (x - this.x0) + this.y0;
  };

  LineSegment.prototype.pointAt = function(tt) {
    return Point(this.x0 + tt * this.dx, this.y0 + tt * this.dy);
  };

  LineSegment.prototype.at = LineSegment.prototype.pointAt;

  LineSegment.prototype.svgString = function() {
    return "M " + (this.start.asString()) + " L " + (this.end.asString());
  };

  LineSegment.prototype.envelope = function(offset, n) {
    var j, len, offsetLine, offsetTT, results, segment, segments;
    if (offset == null) {
      offset = 3;
    }
    if (n == null) {
      n = 1;
    }
    if (n <= 1) {
      return this.asRect().envelope(offset);
    } else {
      offsetTT = -offset / this.length;
      offsetLine = new LineSegment(this.pointAt(offsetTT), this.pointAt(1 - offsetTT));
      segments = offsetLine.splitN(n);
      results = [];
      for (j = 0, len = segments.length; j < len; j++) {
        segment = segments[j];
        results.push(segment.asRect());
      }
      return results;
    }
  };

  LineSegment.prototype.alternatingPathFromPoint = function(aPoint, stepSize) {
    var hiPath, loPath, start, stepTT, tt;
    if (stepSize == null) {
      stepSize = 1;
    }
    aPoint = Point["new"](aPoint);
    start = this._closestTT(aPoint);
    stepTT = stepSize / this.length;
    tt = start;
    loPath = (function() {
      var results;
      results = [];
      while (tt >= stepTT) {
        tt -= stepTT;
        results.push(this.pointAt(tt));
      }
      return results;
    }).call(this);
    tt = start;
    max = 1 - stepTT;
    hiPath = (function() {
      var results;
      results = [];
      while (tt <= max) {
        tt += stepTT;
        results.push(this.pointAt(tt));
      }
      return results;
    }).call(this);
    return interleave(loPath, hiPath);
  };

  LineSegment.prototype._closestTT = function(aPoint, min, max) {
    var AP, ab2, ap_ab, tt;
    AP = aPoint.minus(this.start);
    ab2 = this.dx * this.dx + this.dy * this.dy;
    ap_ab = AP.x * this.dx + AP.y * this.dy;
    tt = ap_ab / ab2;
    if ((min != null) && tt < min) {
      return min;
    } else if ((max != null) && tt > max) {
      return max;
    } else {
      return tt;
    }
  };

  LineSegment.prototype.distToPoint = function(aPoint) {
    var tt;
    aPoint = Point["new"].apply(Point, arguments);
    tt = this._closestTT(aPoint, 0, 1);
    return this.pointAt(tt).distTo(aPoint);
  };

  LineSegment.prototype.closestPointOnSegment = function(aPoint) {
    var tt;
    aPoint = Point["new"].apply(Point, arguments);
    tt = this._closestTT(aPoint, 0, 1);
    return this.pointAt(tt);
  };

  LineSegment.prototype.closestPointOnLine = function(aPoint) {
    var tt;
    aPoint = Point["new"].apply(Point, arguments);
    tt = this._closestTT(aPoint);
    return this.pointAt(tt);
  };

  LineSegment.prototype.normalAt = function(tt) {
    var origin;
    origin = this.pointAt(tt);
    return this.normal.centerAt(origin);
  };

  LineSegment.prototype.normalsAt = function(tt) {
    return this.normalAt(tt).splitFromCenter();
  };

  LineSegment.prototype.intersection = function(aLine) {
    var det, pt;
    det = this.A * aLine.B - aLine.A * this.B;
    if (det === 0) {
      return null;
    }
    pt = Point["new"]((aLine.B * this.C - this.B * aLine.C) / det, (this.A * aLine.C - aLine.A * this.C) / det);
    return pt;
  };

  return LineSegment;

})();

module.exports = LineSegment;

if (require.main === module) {
  l = LineSegment([0, 0], [5, 5]);
  console.log(l);
  console.log(l.svgString());
  console.log(l.distToPoint(2, 3));
  console.log(l.yAt(4));
  console.log(l.pointAt(0.4));
  console.log(l.closestPointOnSegment(-1, 0));
  console.log(l.closestPointOnLine(-1, 0));
  l = LineSegment([0, 0], [15, 15]);
  console.log(l.split(0.25, 0.5, 0.75));
  console.log(l.splitN(2.5));
  console.log(l.normal);
  console.log(l.centerAt(1, 0));
  console.log(l.normalAt(0));
  console.log(l.normalsAt(0));
  console.log(l.normalsAt(1));
  console.log(l.envelope(1, 6));
  console.log(l.splitN(6));
  m = LineSegment([15, 0], [0, 15]);
  console.log(l.intersection(m));
  l = LineSegment([0, 0], [10, 0]);
  console.log(l.extendBy(1));
}
